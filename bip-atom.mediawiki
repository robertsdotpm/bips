<pre>
  BIP: XX
  Title: Atomic Cross Chain Transfers
  Author: Noel Tiernan <tier.nolan@gmail.com>
  Status: Draft
  Type: Standards Track
  Created: 2014-04-29
</pre>

==Abstract==

This BIP describes a method for atomically trading coins between Bitcoin and a Bitcoin-like alternative coin (altcoin). 

==Motivation==

There are many coin trading exchanges.  These websites allow users to trade Bitcoins for altcoin, and also to trade one type altcoin for another.

These sites are centralised in nature.  A p2p coin trading system requires a way for traders to trade their coins in an atomic way.

==Protocol Overview==

The protocol defined in this BIP consists of two stages.  In the first stage, the parties cooperate to generate a set of transactions, without broadcasting.  In the second stage, the transactions are broadcast in a specific ordering.  Communication between the parties is only required during the first stage.

Each party has an incentive to participate in the defined broadcast ordering.  If the protocol stops at any stage before the transaction is committed, both parties can recover their funds using timelocked refund transactions.

It is assumed that Bob wishes to buy A altcoins (ATC) from Alice for B Bitcoins (BTC).  Transaction fees are assumed to be fb for the Bitcoin network and fa for the altcoin network.  Bob will pay all Bitcoin fees and Alice will pay all altcoin fees.  The exchange price agreed between the parties will take this into account.

Public keys are referred to as pub-AN for Alice's keys and pub-BN for Bob's keys.  An optional 3rd party signature is also possible, designated pub-T.

The third party is only required to protect against transaction malleability.  Once transaction malleability is resolved, the third party will not be necessary.  

An additional standard transaction type is required on one of the networks for the protocol to operate.  Trades can be performed between a network which supports P2SH and other that supports OP_HASH160 transaction locking.

===Transaction Creation===

1) Alice sends Bob five public keys (pub-A1, ..., pub-A5)

2) Bob sends Alice five public keys (pub-B1, ..., pub-B5) and Hash160(x)

    x = serialized{pub-B6 OP_CHECKSIG}

3) Bob creates his "bail-in" transaction. 

This transaction can only be spent with both Alice and Bob's signatures.

    Name: Bob.Bail.In
    Input value:     B + 2*fb + change
    Input source:    (From Bob's coins, multiple inputs are allowed)
    Output A value:  B + fb
    ScriptPubKey A:  OP_HASH160 Hash160(P2SH Redeem) OP_EQUAL
    Output B value:  change
    ScriptPubKey B:  <= 100 bytes

    P2SH Redeem:  OP_2 pub-A1 pub-B1 OP_2 OP_CHECKMULTISIG

4) Alice creates her bail-in transaction.

Unlike Bob's bail-in, Alice's bail-in transaction has 3 outputs.

The second output can only be spent if Bob publishes x.  It is also protected by multisig.

    Name: Alice.Bail.In
    Input value:  A + 2*fa + change
    Input source: (From Alice's altcoins, multiple inputs are allowed)
    Output A value: A
    ScriptPubKey A: OP_HASH160 Hash160(P2SH Redeem) OP_EQUAL
    Output B value: fa
    ScriptPubKey B: OP_HASH160 Hash160(x) OP_EQUAL
    Output C value: change
    ScriptPubKey C: <= 100 bytes

    P2SH Redeem:    OP_2 pub-A3 pub-B4 OP_2 OP_CHECKMULTISIG

Note: x = serialized{pub-B6 OP_CHECKSIG}

Output B uses P2SH, this means that Bob must provide x in order to spend it.

5) Bob and Alice exchange bail-in transaction hashes

Bob sends Alice Hash256(Bob.Bail.In) and the corresponding A index

Alice sends Bob Hash256(Alice.Bail.In) and the corresponding A and B indexes

Note: The outputs in the bail-in transaction do not need to be ordered as given in steps 1 and 2.

6) Bob creates Alice's payout transaction. 

This transaction can be spent by Alice, but only if she knows x.

    Name: Alice.Payout
    Input value:  B + fb
    Input source: Bob.Bail.In:A
    Output value: B
    ScriptPubKey: OP_HASH160 Hash160(P2SH Redeem) OP_EQUAL

    P2SH Redeem:  OP_HASH160 Hash160(x) OP_EQUAL_VERIFY pub-A2 OP_CHECKSIG

7) Bob creates his own refund transaction. 

This transaction is timelocked, so that it can't be spent until the timeout (T) has passed.

    Name: Bob.Refund
    Input value:  B + fb
    Input source: Bob.Bail.In:A
    Output value: B
    ScriptPubKey: OP_HASH160 Hash160(P2SH Redeem) OP_EQUAL
    Locktime:     (current block height) + (T / 10 minutes)

    P2SH Redeem:  pub-B2 OP_CHECKSIG

7b) If a trusted third party is desired to protect against transaction malleability, an additional transaction is required.

    Name: Bob.Trusted.Refund
    Input value:  B + fb
    Input source: Bob.Bail.In:A
    Output value: B
    ScriptPubKey: OP_HASH160 Hash160(P2SH Redeem) OP_EQUAL

    P2SH Redeem:  OP_2 pub-B3 pub-T OP_2 OP_CHECKMULTISIG

By acting together, Bob and the third party can spend Bob.Bail.In.

8) Alice creates Bob's payout transaction. 

This transaction can be spent by Bob.  However, since it has Alice.Bail.In:1 as an input, Bob must reveal x in order to spend it.

    Name: Bob.Payout
    Input value:  A
    Input source: Alice.Bail.In:A
    Input value:  fa
    Input source: Alice.Bail.In:B
    Output value: A
    ScriptPubKey: OP_HASH160 Hash160(P2SH Redeem) OP_EQUAL

    P2SH Redeem:  pub-B5 OP_CHECKSIG

9) Alice creates her own refund transaction. 

This transaction is timelocked, so that it can't be spent for until half the timeout (T/2) has passed.  This transaction does not require Alice.Bail.In:1, so Alice can spend it without x being revealed.

    Name: Alice.Refund
    Input value: A
    Input source: Alice.Bail.In:A
    Output value: A - fa
    ScriptPubKey: OP_HASH160 Hash160(P2SH Redeem) OP_EQUAL
    Locktime:     current block height + ((T/2)/(altcoin block rate))

    P2SH Redeem:  pub-A4 OP_CHECKSIG

9b) Alice creates the third party transaction, if required.

    Name: Alice.Trusted.Refund
    Input value:  A
    Input source: Alice.Bail.In:0
    Output value: A - fa
    ScriptPubKey: OP_HASH160 Hash160(P2SH Redeem) OP_EQUAL

    P2SH Redeem:  OP_2 pub-T pub-A5 OP_2 OP_CHECKMULTISIG

9) Bob and Alice exchange transactions

Bob sends Alice unsigned versions of Bob.Refund and Bob.Trusted.Refund and an (half) signed version of Alice.Payout.

Alice signs all three and sends back (half) signed versions of Bob.Refund and Bob.Trusted.Refund.

Alice has a fully signed version of Alice.Payout.

When Bob signs both of them, he has fully signed versions of Bob.Refund and Bob.Trusted.Refund.

Alice sends Bob unsigned versions of Alice.Refund and Alice.Trusted.Refund and an (half) signed version of Bob.Payout.

Bob signs all three and sends back (half) signed versions of Alice.Refund and Alice.Trusted.Refund.

Bob has a fully signed version of Bob.Payout.

When Alice signs both of them, she has fully signed versions of Alice.Refund and Alice.Trusted.Refund.

Each of the parties has fully signed versions of the three transactions relating to them.  

10) Exchange of bail-in transactions

The parties can safely exchange bail-in transactions at this point.  This is not necessary for the protocol, but would allow both parties to verify that the other party at least has a valid bail-in transaction before locking their funds. 

No further communication is required between the parties.  Bob and Alice can determine the state of the transaction by monitoring both chains.

===Transaction Broadcast===

The transactions must be broadcast in a specific order for the composite transaction to be atomic.  

Bob has the following transactions:

* Bob.Bail.In: Bob's bail-in transaction
* Bob.Refund:  Bob's refund transaction (timelocked until the timeout has passed)
* Bob.Payout:  Bob's altcoin payout transaction (can only be spent by revealing x)

Alice has the following transactions

* Alice.Payout:  Alice's Bitcoin payout transaction (can only be spent if Bob reveals x)
* Alice.Bail.In: Alice's bail-in transaction
* Alice.Refund:  Alice's refund transaction (timelocked until half the timeout has passed)

====Step 1: Bail-in by Bob====

Bob broadcasts Bob.Bail.In.

Bob's has no option other than waiting
* He cannot broadcast Bob.Refund since it is timelocked
* He cannot broadcast Bob.Payout since it has Alice.Bail.In as an input

Alice's only broadcast option is to move to step 2
* She cannot broadcast Alice.Payout since she doesn't know x
* She cannot broadcast Alice.Refund since it is timelocked
* She can broadcast Alice.Bail.In, which moves the protocol to step 2

If the protocol ends at this point, Bob can use his refund transaction to recover his Bitcoins after the timeout has expired.

Alice can safely broadcast her bail-in transaction before Bob.  Even if Bob doesn't broadcast his transaction, she can use her refund transaction to recover her funds.

====Step 2: Bail in by Alice====

Alice broadcasts Alice.Bail.In.

Alice has no option other than waiting
* She cannot broadcast Alice.Refund since it is timelocked
* She cannot broadcast Alice.Payout since she doesn't know x

Bob's only broadcast option is to move to step 3
* He cannot broadcast Bob.Refund since it is timelocked
* He can broadcast Bob.Payout since Alice.Bail.In has been broadcast

It is recommended that Bob wait until Alice.Bail.In has been confirmed by a few blocks before proceeding to step 3.

====Step 3: Bob commits to the transaction====

Bob broadcasts Bob.Payout to claim his altcoins.  To spend the 2nd output of Alice.Bail.In requires that Bob reveal x.

This completes Bob's participation in the protocol.

Once Alice.Bail.In has been confirmed to a sufficient depth, Bob should broadcast Bob.Payout as soon as possible.  Since broadcasting Bob.Payout reveals x, if Bob waits until the the locktime on Alice.Refund has expired (or is near to expire), then it creates a race condition.  Alice could broadcast Alice.Refund to get her altcoins back and also broadcast Alice.Payout to claim Bob's Bitcoins.

If he broadcasts immediately, he has half the timeout time for his transction to be confirmed.

Alice has only one broadcast option
* She cannot broadcast Alice.Refund since it is timelocked
* She can broadcast Alice.Payout since she knows x, which moved the protocol to step 4

====Step 4: Alice completes the transaction====

Alice broadcasts Alice.Payout to claim her Bitcoins.

If Alice doesn't claim her Bitcoins before the timeout on Bob.Refund ends, then Bob could use Bob.Refund to recover the Bitcoins he used in the trade.

Since Bob can wait at most half the timeout (T/2) before completing step 3 and Bob.Refund has a timelock of T, Alice has at least half the timeout (T/2) to broadcast Alice.Payout.

==Specification==

JSON-RPC shall be used for communication between the parties.

Hex encoding shall be used for all byte arrays.

Public keys must be serialized using strict SEC format:

    byte(0x02) byte_array(32):                Compressed even key
    byte(0x03) byte_array(32):                Compressed odd key

Compressed keys are mandatory.

When included in transactions, hash_type must be set to 1.

Signatures must be serialized using strict DER format.

    byte(0x30) byte(total_length) byte(0x02) byte(len(R)) byte_array(len(R)) byte(len(s)) byte_array(len(s))

total_length is equal to 3 + len(R) + len(S).

R and S are represented in signed Big Endian format without leading zeros, except that exactly one leading zero is mandatory, if the number would otherwise be negative.  This occurs if the MSB in the first non-zero byte is set.

Transactions shall be serialized using the bitcoin protocol serialization.  Partially signed transactions should include the partial signature in their sigScript fields.  The serialized P2SH Redeem script should be appended to the serialized transaction.

One party shall act as server and one party shall act as client.

The party which selects x and has the longer timeout is defined as the slow trader.  The other party is the fast trader.

===Request Message===

Each message shall have the following format.

    {"id":1, "method": "method.name", "params": [param1, param2]}

id:     The method id, it should increment for each method call
method: The name of the method
params: The method parameters

===Result Message===

The server shall reply to Request methods with a response message.

    {"id": 1, "result": result, "error: Null}

===Error Message===

The server shall reply with an error message, if the request is invalid.

    {"id": 1, "result": Null, "error: [error_code, "error_string"]}

===Methods===

The following methods must be supported.

===Trade Request===

This method is used to initiate the protocol.

    {"id":1, "method": "trade.request", [long_deposit, [third_parties], k_client,
                                         sell_magic_value, sell_coin_amount, sell_coin_fee, 
                                         sell_locktime,
                                         buy_magic_value, buy_coin_amount, buy_coin_fee, 
                                         buy_locktime]}

The parameters are defined as

    slow_trader (boolean):          True if the server is the slow trader, false otherwise
    third_party (list of string):   Hex encoding of acceptable 3rd parties' public key (or Null for no 3rd party)
    k_client (string):              A random hex encoded byte array (32 bytes)
    sell_coin_magic_value (string): Hex encoding of the network magic value for the coin being sold
    sell_coin_amount (number):      An integer count of the number of coins being sold (in the smallest units)
    sell_locktime (number):         The int locktime for the client's refund transaction
    buy_coin_magic_value (string):  Hex encoding of the network magic value for the coin being bought
    buy_coin_amount (number):       An integer count of the number of coins being bought (in the smallest units)
    buy_locktime (number):          The int locktime for the server's refund transaction

The server can decide if the trade is acceptable.

For altcoins with irregular block rates, ensuring that the timeouts occur in the correct order may be difficult.  It is recommended that the more stable chain act as slow trader.  This prevents the slow trader having to wait an extended period if the altcoin's block rate collapses.

Note: The locktime can mean timestamp and block height depending on value.

The response for the method has a subset of the trade information.

    {"id":1, "result": [slow_trader, k_server,
                        sell_coin_amount, sell_coin_fee, sell_locktime,
                        buy_coin_amount, buy_coin_fee, buy_locktime]
             "error": Null}

If the returned values match the request, then the trade is accepted.  Otherwise, it is a counteroffer.

An accepted offer should have at most one 3rd party's public key in the public key list.

If the server does not wish to trade in that coin at all, then the buy_coin_amount, _fee and _locktime should be set to Null in the response.

If the exchange rate is insufficient, servers should modify the sell_coin_amount in preference to modifying the buy_coin_amount.

Servers should accept trades if the client echos back the result to the server.

If a third party is used, the third party's public key must be modified

    k = SHA-256(k_client | k_server)

The result of the SHA-256 operation is considered a big endian encoded unsigned integer.

If k falls outside the finite field, the server should select a different byte array and repeat until success.

The third party's public key is modified to give

    third_party_key_modified = k * third_party_key

This key should be used to generate the third party's refund transaction.

===Exchange Keys===

This method is used to exchange public keys between the parties.  Each party has to provide 5 public keys and the long trader must provide hash_x.  The slow trader should set hash_x to Null.

    {"id": 1, "method":"keys.request", "params": [key1, key2, ... key5, hash_x]}

The server responds with 5 public keys.

    {"id": 1, "result": [key1, key2, ... key5, hash_x], "error": Null}

===Exchange Bail-in Transaction Hashes===

This method is for exchanging bail-in transaction hashes and the A and B indexes.  The fast trader should set B to Null.

    {"id": 1, "method":"bail_in_hash.request", "params": [client_bail_in_hash A B]}

The server responds with its own bail-in transaction hash.

    {"id": 1, "result":"server_bail_in_hash A B", "error": Null}

Both hashes should be encoded as 64 character (32 byte) hashes.  This is the transaction id hash, not hash160.

Note: The fast and slow trader's bail-in transactions are constructed differently.

===Exchange Initial Transactions===

This method is for the parties to exchange unsigned transactions.

    {"id": 1, "method": "exchange.initial_tx", "params": [server_signed_payout, client_refund, client_third_party_refund]}

The parameters are defined as
    server_signed_payout:      This is the signed payout transaction that pays to the server
    client_refund:             This is the locked refund transaction that pays to the client
    client_third_party_refund: This is the third party refund transaction (or Null) that pays to the client

The response is of the same form

    {"id": 1, "result": [server_signed_payout, client_refund, client_third_party_refund], "error": Null}

The parameters are defined as

    client_signed_payout:      This is the signed payout transaction that pays to the client
    server_refund:             This is the locked refund transaction that pays to the server
    server_third_party_refund: This is the third party refund transaction (or Null) that pays to the server

===Exchange Final Transaction===

This method is for the parties to exchange the final versions of the transactions.

    {"id": 1, "method": "exchange.final_tx", "params": [server_signed_refund, server_signed_third_party_refund]}

The parameters are defined as
    server_signed_refund:             This is the locked signed refund transaction that pays to the server
    server_signed_third_party_refund: This is the third party signed refund transaction (or Null) that pays to the client

The response is of the same form

    {"id": 1, "result": [server_signed_payout, client_refund, client_third_party_refund], "error": Null}

The parameters are defined as

    client_signed_refund:             This is the locked signed refund transaction that pays to the client
    client_signed_third_party_refund: This is the third party signed refund transaction (or Null) that pays to the client

Once final transactions are exchanged, no further communication is required.

===Exchange Bail-in Transactions===

This method is for the parties to exchange bail-in transactions.  This allows both parties to broadcast the both bail-in transactions.

Broadcasting the bail-in transaction prior to this step reduces malleability risk by the other party.

    {"id": 1, "method": "exchange.bail.in", params: [server_bail_in]}

The response is of the same form

    {"id": 1, "result": [client_bail_in], "error": Null}

Unlike for the previous two methods, the 

===Trade Cancel===

This allows the parties to back out of a trade before the timeouts are completed.  It is a courtesy and not enforceable.

    {"id": 1, "method": "cancel.transaction", "params": "unlocked_server_signed_refund"}

The parameters are defined as
    unlocked_server_signed_refund:  This is an unlocked version of the refund transaction that pays to the server

The response is
    {"id": 1, "result": [unlocked_client_signed_refund]}

The parameters are defined as
    unlocked_client_signed_refund:  This is an unlocked version of the refund transaction that pays to the client

Since this method is only a courtesy, it doesn't matter that the server could fail to provide the client with the refund transaction.

Once this method is used, the parties should not proceed to step 3.

===Third Party Arbitration===

This method is for submitting transactions to third parties.

    {"id": 1, method:"arbitrate", "params": [k bail_in_transaction refund_transaction new_transaction]}

The parameters are defined as
    k:                      The k parameter encoded as a integer
    third_party_key:        The third party's unmodified public key
    bail_in_transaction:    The original bail-in transaction
    refund_transaction:     The refund transactions, fully signed
    new_transaction:        This is the new refund transaction

The third party must
* Verify that the refund transaction spends the bail_in_transaction
* Verify that the refund transaction is properly signed
* Verify that the new_transaction has the same output
* Verify that the new_transaction has the same locktime as the refund_transactions

The new transaction may have additional outputs.  This allows the third party to be paid.

The response is

    {"id": 1, "result": [signed_new_transaction], "error": Null}

The third party doesn't have to monitor all the chains.  As long as it doesn't allow the locktime to be modified or outputs to be redirected, the system remains secure.

==Compatibility==

The protocol outlined in this BIP requires the use of a single non-standard scriptPubKey.

The Alice.Payout transaction has a scriptPubKey of the following form.

    OP_HASH160 Hash160(x) OP_EQUAL_VERIFY pub-A2 OP_CHECKSIG

All the other scriptPubKeys are standard transactions.

If the transaction is only standard on one of the two networks, then the party selling coin on that network should be the fast trader.

==Reference Implementation==

TBD

== References ==

[1] https://bitcointalk.org/index.php?topic=193281.0

==Copyright==

This document is placed in the public domain.
